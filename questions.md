# Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?

Использование Write-методов типа данных **`strings.Builder`**, так как помогает избежать лишних выделений памяти и копирования

### 2. Что такое интерфейсы, как они применяются в Go?

Абстрактные типы данных, определяющие набор методов, но не содержащие конкретной реализации. Интерфейсы позволяют определить поведение, которое должны предоставлять типы данных, независимо от их конкретной реализации.

В Go интерфейс определяется как набор методов. Любой тип, который реализует все методы этого интерфейса, автоматически удовлетворяет интерфейсу. Нет необходимости явно указывать, что тип реализует интерфейс; если он имеет все необходимые методы, то он является реализацией интерфейса.

### 3. Чем отличаются RWMutex от Mutex?

RWMutex дает расширенный функционал, позволяющий параллельное чтение данных, подойдёт, если преобладают операции чтения над записью. Mutex лучше подойдёт, если операции записи преобладают над чтением.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Буф. канал имеет некоторую вместимость (буфер), он не блокирует горутину, пока буфер не будет заполнен. Обычный канал можно назвать частным случаем буф. канала, чья вместимость равна 1 записи, поэтому он блокирует горутину сразу, для следующей записи, если данные их него ещё не прочитали, либо же блокирует горутину для следующего чтения, если в нём ничего нет.

### 5. Какой размер у структуры struct{}{}?

0 байт
Используется, когда нужна структура данных без дополнительных данных, можно использовать ее для канала сигнализации или для представления отсутствия данных.

### 6. Есть ли в Go перегрузка методов или операторов?

В Go нет перегрузки (т.е., определения методов с одинаковым именем, но разными параметрами) методов или операторов, каждая функция или метод имеет уникальное имя.

### 7. В какой последовательности будут выведены элементы map[int]int?

Порядок обхода мапы всегда случайный, однако функция fmt.Println под капотом сортирует мапу по ключам.

### 8. В чем разница make и new?

`make()` используется только для создания слайсов, мап и каналов, возвращает значение создаваемого типа, выделяет место в памяти и инициализирует внутреннюю структуру данных, подготавливая значение для использования

`new()` используется для любых структур, возвращает указатель на создаваемый тип, выделяет место в памяти, но не инициализирует внутреннюю структуру данных

### 9. Сколько существует способов задать переменную типа slice или map?

1. `make()`
2. `var`
3. `:=`

### 10. Что выведет данная программа и почему?

```go
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```
Вывод:
```bash
1
1
```
В функции изменяется копия поинтера. Если мы хотим, чтобы наша функция update() работала можем переписать её следующи образом:
```go
func update(p *int) {
	b := 2
	*p = b
}
```

### 11. Что выведет данная программа и почему?

```go
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
Вывод:
```bash
4
1
0
2
3
fatal error: all goroutines are asleep - deadlock!
```
Числа от 0 до 4 выведутся в случайном порядке, после чего главная горутина закончится дедлоком. Это произойдёт из-за того, что в горутину передана копия WaitGroup, а не указать на неё, из-за чего счётчик ожиданий никогда не обнулится.

### 12. Что выведет данная программа и почему?
```go
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
Будет выведен 0, так как переменная n объявляется заново в другой области видимости.

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```
Вывод:
```bash
[100 2 3 4 5]
```
Обращаясь по индексу к элементу массива, мы изменяем копию и изначальный массив, а расширяя его функцией `append()` мы переносим копию массива в другую область памяти.


### 14. Что выведет данная программа и почему?

```go
func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```
Вывод:
```bash
[b b a][a a]
```
Похоже с предыдущим номером 13. Копия массива, при увеличении его ёмкости, переносится в другую область памяти.
